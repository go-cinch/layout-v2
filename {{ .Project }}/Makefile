GOHOSTOS:=$(shell go env GOHOSTOS)
GOPATH:=$(shell go env GOPATH)
VERSION=$(shell git describe --tags --always)
GRPC_PORT:=$(shell grep -A 3 'grpc:' configs/server.yaml | grep 'addr:' | awk -F':' '{print $$3}' | tr -d ' ')
HTTP_PORT:=$(shell grep -A 3 'http:' configs/server.yaml | grep 'addr:' | awk -F':' '{print $$3}' | tr -d ' ')

# Tools directory
TOOLS_DIR := .tools
PROTOC_GEN_GO := $(TOOLS_DIR)/bin/protoc-gen-go
PROTOC_GEN_GO_GRPC := $(TOOLS_DIR)/bin/protoc-gen-go-grpc
PROTOC_GEN_GO_ERRORS := $(TOOLS_DIR)/bin/protoc-gen-go-errors
PROTOC_GEN_GO_HTTP := $(TOOLS_DIR)/bin/protoc-gen-go-http
PROTOC_GEN_OPENAPI := $(TOOLS_DIR)/bin/protoc-gen-openapi
PROTOC_GEN_VALIDATE := $(TOOLS_DIR)/bin/protoc-gen-validate
WIRE := $(TOOLS_DIR)/bin/wire
{{ if .Computed.enable_db_final }}
SQL_MIGRATE := $(TOOLS_DIR)/bin/sql-migrate
{{- if eq .Computed.orm_type_final "gorm" }}
GENTOOL := $(TOOLS_DIR)/bin/gentool
{{- end }}
{{ end }}

# golangci-lint configuration
GOLANGCI_LINT_VERSION ?= v2.6.2
GOLANGCI_LINT_DIR := $(TOOLS_DIR)/golangci-lint/$(GOLANGCI_LINT_VERSION)
GOLANGCI_LINT := $(GOLANGCI_LINT_DIR)/bin/golangci-lint

ifeq ($(GOHOSTOS), windows)
	Git_Bash= $(subst cmd\,bin\bash.exe,$(dir $(shell where git)))
	INTERNAL_PROTO_FILES=$(shell $(Git_Bash) -c "find internal -name *.proto")
	API_PROTO_FILES=$(shell $(Git_Bash) -c "find api -name *.proto")
else
	INTERNAL_PROTO_FILES=$(shell find internal -name *.proto)
	API_PROTO_FILES=$(shell find api -maxdepth 2 -name *.proto)
endif

.PHONY: init
# init env
init:
	@mkdir -p $(TOOLS_DIR)/bin
	@GOBIN=$(PWD)/$(TOOLS_DIR)/bin go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
	@GOBIN=$(PWD)/$(TOOLS_DIR)/bin go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
	@GOBIN=$(PWD)/$(TOOLS_DIR)/bin go install github.com/go-kratos/kratos/cmd/protoc-gen-go-errors/v2@latest
	@GOBIN=$(PWD)/$(TOOLS_DIR)/bin go install github.com/go-kratos/kratos/cmd/protoc-gen-go-http/v2@latest
	@GOBIN=$(PWD)/$(TOOLS_DIR)/bin go install github.com/google/gnostic/cmd/protoc-gen-openapi@latest
	@GOBIN=$(PWD)/$(TOOLS_DIR)/bin go install github.com/envoyproxy/protoc-gen-validate@latest
	@GOBIN=$(PWD)/$(TOOLS_DIR)/bin go install github.com/google/wire/cmd/wire@latest
{{ if .Computed.enable_db_final }}
	@GOBIN=$(PWD)/$(TOOLS_DIR)/bin go install github.com/rubenv/sql-migrate/...@latest
{{- if eq .Computed.orm_type_final "gorm" }}
	@GOBIN=$(PWD)/$(TOOLS_DIR)/bin GOTOOLCHAIN=go1.24.6 go install gorm.io/gen/tools/gentool@latest
{{- end }}
{{ end }}
	@echo "Installing golangci-lint $(GOLANGCI_LINT_VERSION)..."
	@mkdir -p $(GOLANGCI_LINT_DIR)
	@curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(GOLANGCI_LINT_DIR)/bin $(GOLANGCI_LINT_VERSION)

.PHONY: config
# generate internal proto
config:
	@protoc --plugin=protoc-gen-go=$(PWD)/$(PROTOC_GEN_GO) \
	       --proto_path=./internal \
	       --proto_path=./third_party \
	       --go_out=paths=source_relative:./internal \
	       $(INTERNAL_PROTO_FILES)

.PHONY: api
# generate api proto
api:
	@mkdir -p docs
	@for NAME in $(API_PROTO_FILES); do \
		echo $$NAME; \
		protoc --plugin=protoc-gen-go=$(PWD)/$(PROTOC_GEN_GO) \
			--plugin=protoc-gen-go-grpc=$(PWD)/$(PROTOC_GEN_GO_GRPC) \
			--plugin=protoc-gen-go-errors=$(PWD)/$(PROTOC_GEN_GO_ERRORS) \
			--plugin=protoc-gen-go-http=$(PWD)/$(PROTOC_GEN_GO_HTTP) \
			--plugin=protoc-gen-openapi=$(PWD)/$(PROTOC_GEN_OPENAPI) \
			--plugin=protoc-gen-validate=$(PWD)/$(PROTOC_GEN_VALIDATE) \
			--proto_path=./api \
			--proto_path=./third_party \
			--go_out=. \
			--go-errors_out=. \
			--go-http_out=. \
			--go-grpc_out=. \
			--validate_out=lang=go:. \
			--openapi_out=fq_schema_naming=true,default_response=false,output_mode=source_relative:docs \
			$$NAME; \
	done
	@echo 'You can import *.json into https://editor.swagger.io/'

.PHONY: wire
# generate wire
wire:
	cd cmd/{{.Computed.service_name_final}} && ../../$(TOOLS_DIR)/bin/wire

{{ if .Computed.enable_db_final }}
.PHONY: gen-createdb
# create database (only needed once)
gen-createdb:
{{- if eq .Computed.db_type_final "postgres" }}
	@echo "Creating PostgreSQL database {{ .Computed.service_name_final }}..."
	@if docker ps --filter "name=pg" --format "{{ print "{{" }}.Names{{ print "}}" }}" | grep -q "^pg$$"; then \
		echo "Found running PostgreSQL container: pg"; \
		PG_USER=$$(grep 'dsn:' configs/db.yaml | sed 's/.*user=\([^ ]*\).*/\1/'); \
		PG_PASSWORD=$$(grep 'dsn:' configs/db.yaml | sed 's/.*password=\([^ ]*\).*/\1/'); \
		echo "Using PostgreSQL user: $$PG_USER"; \
		docker exec -e PGPASSWORD=$$PG_PASSWORD pg psql -U $$PG_USER -d postgres -c "CREATE DATABASE {{ .Computed.service_name_final }};" 2>&1 | grep -v "already exists" || true; \
		echo "âœ“ Database '{{ .Computed.service_name_final }}' is ready"; \
	elif docker ps -a --filter "name=pg" --format "{{ print "{{" }}.Names{{ print "}}" }}" | grep -q "^pg$$"; then \
		echo "âŒ PostgreSQL container 'pg' exists but not running. Please start it first."; \
		exit 1; \
	else \
		echo "âŒ No PostgreSQL container named 'pg' found."; \
		echo "Please create database manually using psql or other tools."; \
		exit 1; \
	fi
{{- else }}
	@echo "Creating MySQL database {{ .Computed.service_name_final }}..."
	@if docker ps --filter "name=mysql" --format "{{ print "{{" }}.Names{{ print "}}" }}" | grep -q "^mysql$$"; then \
		echo "Found running MySQL container: mysql"; \
		MYSQL_USER=$$(grep 'dsn:' configs/db.yaml | sed 's/.*\/\/\([^:]*\):.*/\1/' | sed 's/^\s*"\?//' | sed 's/\s*$$//' | cut -d: -f1); \
		MYSQL_PASSWORD=$$(grep 'dsn:' configs/db.yaml | sed 's/.*\/\/[^:]*:\([^@]*\)@.*/\1/'); \
		echo "Using MySQL user: $$MYSQL_USER"; \
		docker exec mysql mysql -u$$MYSQL_USER -p$$MYSQL_PASSWORD -e "CREATE DATABASE IF NOT EXISTS {{ .Computed.service_name_final }};" 2>&1 | grep -v "already exists" || true; \
		echo "âœ“ Database '{{ .Computed.service_name_final }}' is ready"; \
	elif docker ps -a --filter "name=mysql" --format "{{ print "{{" }}.Names{{ print "}}" }}" | grep -q "^mysql$$"; then \
		echo "âŒ MySQL container 'mysql' exists but not running. Please start it first."; \
		exit 1; \
	else \
		echo "âŒ No MySQL container named 'mysql' found."; \
		echo "Please create database manually using mysql client or other tools."; \
		exit 1; \
	fi
{{- end }}

.PHONY: gen-config
# generate sql-migrate config from db.yaml (internal use)
gen-config:
	@echo "development:" > /tmp/sql-migrate-$$$$.yml
	@echo "  dialect: $$(grep 'driver:' configs/db.yaml | awk '{print $$2}')" >> /tmp/sql-migrate-$$$$.yml
	@echo "  datasource: $$(grep 'dsn:' configs/db.yaml | sed 's/.*dsn: *"\(.*\)".*/\1/' | sed 's/TimeZone=UTC//')" >> /tmp/sql-migrate-$$$$.yml
	@echo "  dir: internal/db/migrations" >> /tmp/sql-migrate-$$$$.yml
	@echo "  table: schema_migrations" >> /tmp/sql-migrate-$$$$.yml
	@echo "/tmp/sql-migrate-$$$$.yml"

.PHONY: gen-up
# run database migrations up using sql-migrate
gen-up:
	@echo "Running database migrations up..."
	@TMP_CONFIG=$$(mktemp /tmp/sql-migrate.XXXXXX.yml); \
	echo "development:" > $$TMP_CONFIG; \
	echo "  dialect: $$(grep 'driver:' configs/db.yaml | awk '{print $$2}')" >> $$TMP_CONFIG; \
	echo "  datasource: $$(grep 'dsn:' configs/db.yaml | sed 's/.*dsn: *"\(.*\)".*/\1/' | sed 's/TimeZone=UTC//')" >> $$TMP_CONFIG; \
	echo "  dir: internal/db/migrations" >> $$TMP_CONFIG; \
	echo "  table: schema_migrations" >> $$TMP_CONFIG; \
	$(SQL_MIGRATE) up -config=$$TMP_CONFIG -env=development; \
	EXIT_CODE=$$?; \
	rm -f $$TMP_CONFIG; \
	if [ $$EXIT_CODE -ne 0 ]; then \
		echo ""; \
		echo "ðŸ’¡ Hint: If database doesn't exist, run: make gen-createdb"; \
	fi; \
	exit $$EXIT_CODE

.PHONY: gen-down
# run database migrations down using sql-migrate
gen-down:
	@echo "Running database migrations down..."
	@TMP_CONFIG=$$(mktemp /tmp/sql-migrate.XXXXXX.yml); \
	echo "development:" > $$TMP_CONFIG; \
	echo "  dialect: $$(grep 'driver:' configs/db.yaml | awk '{print $$2}')" >> $$TMP_CONFIG; \
	echo "  datasource: $$(grep 'dsn:' configs/db.yaml | sed 's/.*dsn: *"\(.*\)".*/\1/' | sed 's/TimeZone=UTC//')" >> $$TMP_CONFIG; \
	echo "  dir: internal/db/migrations" >> $$TMP_CONFIG; \
	echo "  table: schema_migrations" >> $$TMP_CONFIG; \
	$(SQL_MIGRATE) down -config=$$TMP_CONFIG -env=development; \
	rm -f $$TMP_CONFIG

.PHONY: gen-status
# show database migration status using sql-migrate
gen-status:
	@TMP_CONFIG=$$(mktemp /tmp/sql-migrate.XXXXXX.yml); \
	echo "development:" > $$TMP_CONFIG; \
	echo "  dialect: $$(grep 'driver:' configs/db.yaml | awk '{print $$2}')" >> $$TMP_CONFIG; \
	echo "  datasource: $$(grep 'dsn:' configs/db.yaml | sed 's/.*dsn: *"\(.*\)".*/\1/' | sed 's/TimeZone=UTC//')" >> $$TMP_CONFIG; \
	echo "  dir: internal/db/migrations" >> $$TMP_CONFIG; \
	echo "  table: schema_migrations" >> $$TMP_CONFIG; \
	$(SQL_MIGRATE) status -config=$$TMP_CONFIG -env=development; \
	rm -f $$TMP_CONFIG

{{- if eq .Computed.orm_type_final "gorm" }}

.PHONY: gen-model
# generate GORM models from database using gentool
gen-model:
	@echo "Generating GORM models from database..."
	@DB_TYPE=$$(grep 'driver:' configs/db.yaml | awk '{print $$2}'); \
	DSN=$$(awk '/^[[:space:]]*driver:/{flag=1} flag && /^[[:space:]]*dsn:/{print; exit}' configs/db.yaml | sed 's/.*dsn: *"\(.*\)".*/\1/'); \
	echo "Database: $$DB_TYPE"; \
	echo "DSN: $$DSN"; \
	$(GENTOOL) -dsn "$$DSN" \
		-db $$DB_TYPE \
		-onlyModel \
		-outPath internal/data/model \
		-modelPkgName model \
		-fieldNullable \
		-fieldWithIndexTag \
		-fieldWithTypeTag
	@echo "Removing excluded tables..."; \
	EXCLUDE_TABLES=$$(awk '/^[[:space:]]*exclude:/{flag=1; next} /^[[:space:]]*[a-zA-Z]/{flag=0} flag && /^[[:space:]]*-/{print}' configs/db.yaml | sed 's/^ *- *//' | tr '\n' ' '); \
	if [ -n "$$EXCLUDE_TABLES" ]; then \
		echo "Excluded tables: $$EXCLUDE_TABLES"; \
		for table in $$EXCLUDE_TABLES; do \
			rm -f internal/data/model/$${table}.gen.go; \
			echo "  - Removed $${table}.gen.go"; \
		done; \
	fi
	@echo "Applying customizations..."; \
	USE_CARBON=$$(grep 'useCarbonTime:' configs/db.yaml | awk '{print $$2}'); \
	USE_UINT64=$$(grep 'useUint64Id:' configs/db.yaml | awk '{print $$2}'); \
	REMOVE_PTR=$$(grep 'removeNullablePointer:' configs/db.yaml | awk '{print $$2}'); \
	JSON_STRING_FIELDS=$$(awk '/^[[:space:]]*jsonStringFields:/{flag=1; next} /^[[:space:]]*[a-zA-Z]/{flag=0} flag && /^[[:space:]]*-/{print}' configs/db.yaml | sed 's/^ *- *//' | tr '\n' '|' | sed 's/|$$//'); \
	for file in internal/data/model/*.gen.go; do \
		if [ -f "$$file" ]; then \
			if [ "$$USE_CARBON" = "true" ]; then \
				sed -i.bak 's/"time"/"github.com\/golang-module\/carbon\/v2"/g' "$$file"; \
				sed -i.bak 's/\*time\.Time/*carbon.DateTime/g' "$$file"; \
				sed -i.bak 's/time\.Time/carbon.DateTime/g' "$$file"; \
				echo "  - Converted time.Time to carbon.DateTime in $$file"; \
			fi; \
			if [ "$$USE_UINT64" = "true" ]; then \
				sed -i.bak 's/ID[[:space:]]*int64/ID        uint64/g' "$$file"; \
				echo "  - Converted int64 to uint64 for ID in $$file"; \
			fi; \
			if [ -n "$$JSON_STRING_FIELDS" ]; then \
				IFS='|' read -ra FIELDS <<< "$$JSON_STRING_FIELDS"; \
				for field in "$${FIELDS[@]}"; do \
					sed -i.bak "s/\(json:\"$$field\)\"/\1,string\"/g" "$$file"; \
				done; \
				echo "  - Added ,string to JSON tags for fields: $$JSON_STRING_FIELDS in $$file"; \
			fi; \
			if [ "$$REMOVE_PTR" = "true" ]; then \
				sed -i.bak 's/\*carbon\.DateTime/carbon.DateTime/g' "$$file"; \
				sed -i.bak 's/\*time\.Time/time.Time/g' "$$file"; \
				sed -i.bak 's/\*string/string/g' "$$file"; \
				sed -i.bak 's/\*int64/int64/g' "$$file"; \
				sed -i.bak 's/\*int32/int32/g' "$$file"; \
				sed -i.bak 's/\*float64/float64/g' "$$file"; \
				sed -i.bak 's/\*bool/bool/g' "$$file"; \
				echo "  - Removed nullable pointers in $$file"; \
			fi; \
			rm -f "$$file.bak"; \
		fi; \
	done
	@echo "Adding associations..."; \
	ASSOCIATIONS=$$(awk '/^[[:space:]]*association:/{flag=1; next} /^[[:space:]]*[a-zA-Z]/{flag=0} flag && /^[[:space:]]*-/{print}' configs/db.yaml | sed "s/^ *- *'//;s/'$$//"); \
	if [ -n "$$ASSOCIATIONS" ]; then \
		echo "$$ASSOCIATIONS" | while IFS= read -r assoc; do \
			if [ -z "$$assoc" ]; then continue; fi; \
			MODEL_TABLE=$$(echo "$$assoc" | cut -d'|' -f1); \
			RELATED_TABLE=$$(echo "$$assoc" | cut -d'|' -f2); \
			FIELD_NAME=$$(echo "$$assoc" | cut -d'|' -f3); \
			RELATION_TYPE=$$(echo "$$assoc" | cut -d'|' -f4); \
			GORM_TAG=$$(echo "$$assoc" | cut -d'|' -f5); \
			MODEL_FILE="internal/data/model/$${MODEL_TABLE}.gen.go"; \
			if [ ! -f "$$MODEL_FILE" ]; then continue; fi; \
			STRUCT_NAME=$$(grep "^type.*struct" "$$MODEL_FILE" | awk '{print $$2}'); \
			IS_SLICE=false; \
			FIELD_TYPE="$$RELATED_TABLE"; \
			if echo "$$FIELD_NAME" | grep -q '^\[\]'; then \
				IS_SLICE=true; \
				FIELD_NAME=$$(echo "$$FIELD_NAME" | sed 's/^\[\]//'); \
			fi; \
			if echo "$$FIELD_TYPE" | grep -q '^\*'; then \
				FIELD_TYPE=$$(echo "$$FIELD_TYPE" | sed 's/^\*//'); \
			else \
				RELATED_MODEL=$$(grep "^type.*$$RELATED_TABLE.*struct" internal/data/model/*.gen.go 2>/dev/null | head -1 | awk '{print $$2}'); \
				if [ -n "$$RELATED_MODEL" ]; then \
					FIELD_TYPE="$$RELATED_MODEL"; \
				else \
					RELATED_PASCAL=$$(echo "$$RELATED_TABLE" | awk '{for(i=1;i<=NF;i++){sub(/./,toupper(substr($$i,1,1)),$$i);}}1' FS="_" OFS=""); \
					FIELD_TYPE="$$RELATED_PASCAL"; \
				fi; \
			fi; \
			if [ "$$IS_SLICE" = "true" ]; then \
				FIELD_TYPE="[]$$FIELD_TYPE"; \
			fi; \
			if [ "$$RELATION_TYPE" = "has_one" ] && [ "$$IS_SLICE" = "false" ]; then \
				FIELD_TYPE="*$$FIELD_TYPE"; \
			elif [ "$$RELATION_TYPE" = "has_many" ]; then \
				FIELD_TYPE="[]$$FIELD_TYPE"; \
			fi; \
			JSON_NAME=$$(echo "$$FIELD_NAME" | awk '{print tolower($$0)}'); \
			FIELD_LINE="	$$FIELD_NAME $${FIELD_TYPE} \`gorm:\\\"$$GORM_TAG\\\" json:\\\"$$JSON_NAME\\\"\`"; \
			awk -v line="$$FIELD_LINE" '/^}$$/ && !found {print line; found=1} {print}' "$$MODEL_FILE" > "$$MODEL_FILE.tmp" && mv "$$MODEL_FILE.tmp" "$$MODEL_FILE"; \
			echo "  - Added $$FIELD_NAME to $$MODEL_TABLE"; \
		done; \
	fi
	@echo "âœ“ Models generated in internal/data/model/"
{{- end }}
{{ end }}

.PHONY: lint
# run code linters (gofmt + golangci-lint)
lint:
	@echo "Running gofmt..."
	@gofmt -w -s .
	@if [ -x "$(GOLANGCI_LINT)" ]; then \
		$(GOLANGCI_LINT) run --fix ./...; \
	elif command -v golangci-lint >/dev/null 2>&1; then \
		golangci-lint run --fix ./...; \
	else \
		echo "golangci-lint not found. Run 'make init' to install $(GOLANGCI_LINT_VERSION), or install via: brew install golangci-lint"; \
		echo "Running basic checks (go vet, gofmt) instead..."; \
		go vet ./...; \
		[ -z "$$(gofmt -s -l .)" ] || (echo "Files not gofmt'd:" && gofmt -s -l . && exit 1); \
	fi

.PHONY: build
# build
build:
	mkdir -p bin/ && go build -ldflags "-s -w -X main.Version=$(VERSION)" -o ./bin/ ./...

.PHONY: run
# run
run:
	cd cmd/{{.Computed.service_name_final}} && go run .

.PHONY: debug-grpc
# debug grpc with grpcui
debug-grpc:
	@echo "Starting gRPC UI on port $(GRPC_PORT)..."
	@API_PROTO=$$(find api -name "*.proto" | head -1); \
	if [ -n "$$API_PROTO" ]; then \
		echo "Using proto file: $$API_PROTO"; \
		grpcui -plaintext \
			-use-reflection \
			-import-path ./api \
			-import-path ./third_party \
			-proto $$API_PROTO \
			"127.0.0.1:$(GRPC_PORT)"; \
	else \
		echo "No proto files found, using reflection only..."; \
		grpcui -plaintext "127.0.0.1:$(GRPC_PORT)"; \
	fi

.PHONY: debug-http
# debug http api with swagger ui
debug-http:
	@OPENAPI_FILE=$$(find docs -name "*.openapi.yaml" | head -1); \
	if [ -z "$$OPENAPI_FILE" ]; then \
		echo "Error: No OpenAPI file found in docs directory. Please run 'make api' first."; \
		exit 1; \
	fi; \
	echo "Generating Swagger UI with embedded OpenAPI spec..."; \
	TMP_YAML="docs/.openapi-temp.yaml"; \
	awk 'BEGIN {added=0; in_info=0} \
		/^openapi:/ {print; next} \
		/^info:/ {in_info=1; print; next} \
		in_info && /^[a-z]+:/ && !added { \
			print "servers:"; \
			print "    - url: http://localhost:$(HTTP_PORT)"; \
			added=1; \
		} \
		/^servers:/ {skip=1; next} \
		skip && /^    - / {next} \
		skip && /^[a-z]+:/ {skip=0} \
		{if (!skip) print}' "$$OPENAPI_FILE" | \
		sed 's/\\/\\\\/g; s/`/\\`/g' > "$$TMP_YAML"; \
	awk '/OPENAPI_YAML_CONTENT/ { \
		print "      const openapiYaml = `"; \
		while ((getline line < "'"$$TMP_YAML"'") > 0) print line; \
		print "`"; \
		next; \
	} \
	{print}' docs/swagger-for-debug.html > docs/swagger-ui.html; \
	rm -f "$$TMP_YAML"; \
	echo "Swagger UI available at:"; \
	echo "  http://localhost:$(HTTP_PORT)/docs/swagger-ui.html"; \
	echo ""; \
	echo "Make sure your service is running with 'make run'"; \
	open "http://localhost:$(HTTP_PORT)/docs/swagger-ui.html" || \
	echo "Please open http://localhost:$(HTTP_PORT)/docs/swagger-ui.html in your browser"

.PHONY: all
# generate all
all:
	go mod tidy
	make api
	make config
	make wire
	make lint

# show help
help:
	@echo ''
	@echo 'Usage:'
	@echo ' make [target]'
	@echo ''
	@echo 'Targets:'
	@awk '/^[a-zA-Z\-\_0-9]+:/ { \
	helpMessage = match(lastLine, /^# (.*)/); \
		if (helpMessage) { \
			helpCommand = substr($$1, 0, index($$1, ":")-1); \
			helpMessage = substr(lastLine, RSTART + 2, RLENGTH); \
			printf "\033[36m%-22s\033[0m %s\n", helpCommand,helpMessage; \
		} \
	} \
	{ lastLine = $$0 }' $(MAKEFILE_LIST)

.DEFAULT_GOAL := help
